<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: refactor | Blog da HE:labs]]></title>
  <link href="http://helabs.com.br/blog/categories/refactor/atom.xml" rel="self"/>
  <link href="http://helabs.com.br/blog/"/>
  <updated>2013-08-30T10:44:41-03:00</updated>
  <id>http://helabs.com.br/blog/</id>
  <author>
    <name><![CDATA[Time HE:labs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Métodos estáticos, porque evitá-los]]></title>
    <link href="http://helabs.com.br/blog/2013/03/13/metodos-estaticos-porque-evita-los/"/>
    <updated>2013-03-13T08:00:00-03:00</updated>
    <id>http://helabs.com.br/blog/2013/03/13/metodos-estaticos-porque-evita-los</id>
    <content type="html"><![CDATA[<p>Aparentemente existe na cultura de alguns desenvolvedores uma certa convenção sobre quando usar métodos estáticos. Se é um método relativamente simples, que itera sobre uma coleção dos objetos da classe em si, implementar um método estático é uma forma possível de implementação.</p>

<p>Diga-se que uma API está sendo feita, e é preciso retornar os usuários novos em um JSON bem específico às características da aplicação. Segue um exemplo, extraído de um projeto real:</p>

<!-- more -->


<p>```ruby
class User &lt; ActiveRecord::Base
  # ...
  def self.last_users_since(time)</p>

<pre><code>response_data = {new_users: []}
where(updated_at: time..Time.now).each do |user|
  user_hash = user.as_new_user
  response[:new_users] &lt;&lt; (user_hash) if user_hash.present?
end
response_data
</code></pre>

<p>  end
  # ...
end
```</p>

<p>Da forma como se encontra, temos alguns problemas:</p>

<ul>
<li>É um método relativamente complexo;</li>
<li>Não é um método fácil de ler;</li>
<li>Existe um método no objeto user que só serve pra essa API (<code>User#as_new_user</code>);</li>
<li>É chato de testar, pois só temos o retorno para ser testado.</li>
</ul>


<p>Mas até então, ainda não é um problema.</p>

<p>Só que software é uma coisa que muda constantemente, e o cliente resolveu alterar a API. Agora existe um campo booleano em user chamado <code>synced</code> que dita quais objetos vão ser retornados para a API e, em seguida, considerar os mesmos como sincronizados. Ou seja, uma nova chamada à API não vai mais retornar os mesmos objetos, e sim somente os não sincronizados. Existe também um novo campo no JSON que indica quando a chamada foi resolvida.</p>

<p>Altera-se o método para a nova necessidade:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  # ...
  def self.sync_unsynchronized_users</p>

<pre><code>response_data = {new_users: [], synced_at: Time.now}
where(synced: false).each do |user|
  user_hash = user.as_new_user
  response[:new_users] &lt;&lt; (user_hash) if user_hash.present?
  user.sync!
end
response_data
</code></pre>

<p>  end
  # ...
end
```</p>

<p>Todos os problemas ainda existem e dificilmente serão resolvidos se mantermos o método estático.</p>

<p>E o pior de tudo: Mesmo com a introdução acima, a implementação é um pouco confusa. Imagine daqui há 2 meses quando algum desenvolvedor (ou até mesmo o próprio que escreveu) tiver que pegar esse código pra entender. Ainda que seja perfeitamente possível que se compreenda como o mesmo funciona, um método estático não declara intenção, os testes normalmente não são tão claros quanto se gostaria, e introduzir qualquer nova funcionalidade traz uma certa insegurança.</p>

<h2>Extraindo um método estático para uma nova classe</h2>

<p>Extrair um método complexo para uma classe é um dos refactors mais clássicos e, no caso dos métodos estáticos, ataca-se os principais problemas:</p>

<ul>
<li>Facilita a leitura;</li>
<li>Declara-se intenções através de nomes de métodos;</li>
<li>Melhora a testabilidade.</li>
</ul>


<p>O método acima extraído para uma classe ficaria assim:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  # ...
  def self.sync_unsynchronized_users</p>

<pre><code>UsersSyncer.new.sync!
</code></pre>

<p>  end
  # ...
end</p>

<p>class UsersSyncer
  attr_reader :recently_synchronized_users
  def initialize</p>

<pre><code>@recently_synchronized_users = []
</code></pre>

<p>  end</p>

<p>  def unsyncronized_users</p>

<pre><code>User.where(synced: false)
</code></pre>

<p>  end</p>

<p>  def sync!</p>

<pre><code>add_and_sync_users
response_hash
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def response_hash
  {new_users: recently_synchronized_users, synced_at: Time.now}
end

def add_and_sync_users
  unsyncronized_users.each do |user|
    mark_as_sync(user)
    add_user_to_list_if_present(user)
  end
end

def mark_as_sync(user)
  user.sync!
end

def add_user_to_list_if_present(user)
  user_hash = format_user_for_api(user)
  @recently_synchronized_users &lt;&lt; if user_hash.present?
end

def format_user_for_api(user)
  # método extraído de User
end
</code></pre>

<p>end
```</p>

<p>Nota-se que o método estático ainda existe, mas somente como uma interface. Esse é um dos poucos casos em que se é aceitável a criação de métodos estáticos, já que é bem prático chamar <code>User.sync_unsynchronized_users</code>.</p>

<p>O método <code>as_new_user</code> foi extraído de <code>User</code> porque neste caso somente
era usado somente uma vez. Poderia ficar em <code>User</code>, mas acredito ficar
mais claro desta forma.</p>

<p>Ler a classe acima 2 meses depois requer muito menos esforço por parte do desenvolvedor para compreender o funcionamento da mesma, e com certeza os testes estarão mais claros, além da complexidade ter diminuído consideravelmente.</p>
]]></content>
  </entry>
  
</feed>
