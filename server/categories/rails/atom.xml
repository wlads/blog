<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Blog da HE:labs]]></title>
  <link href="http://helabs.com.br/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://helabs.com.br/blog/"/>
  <updated>2013-08-30T10:44:41-03:00</updated>
  <id>http://helabs.com.br/blog/</id>
  <author>
    <name><![CDATA[Time HE:labs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Usando decorators nos models Rails de forma intrusiva]]></title>
    <link href="http://helabs.com.br/blog/2013/06/28/usando-decorators-nos-models-rails-de-forma-intrusiva/"/>
    <updated>2013-06-28T15:00:00-03:00</updated>
    <id>http://helabs.com.br/blog/2013/06/28/usando-decorators-nos-models-rails-de-forma-intrusiva</id>
    <content type="html"><![CDATA[<p>Muito já se falou sobre decorators nos últimos tempos, até mesmo por <a href="http://helabs.com.br/blog/categories/decorator/">aqui</a>. Melhorar a legibilidade e remover lógica das views de uma aplicação é um assunto que <a href="http://helabs.com.br/blog/2012/11/16/tech-talk-rodrigo-pinto-explorando-as-views-rails/">me interessa</a> já faz algum tempo. Nesse post falarei sobre a alternativa que, no meu ponto de vista, preencheu a lacuna do problema decorators de views no rails .</p>

<!--more-->


<p>Há diversas formas de implementar um decorator e já existem inúmeras gems que auxiliam neste trabalho, como o <a href="https://github.com/fnando/simple_presenter">simple_presenter</a> e o <a href="https://github.com/drapergem/draper">draper</a>. O que me incomodava em todas as diversas soluções existentes, é  o desenvolvedor ter que passar o objeto ou a coleção de objetos para a classe do decorator para que fosse <em>decorado</em>. Pensando no caso de uma action, ela teria de ser alterada, como pode ser visto no exemplo a seguir:</p>

<p>```ruby</p>

<h1>any controller...</h1>

<p>def index
  @users = UserPresenter.map(User.all) # simple presenter
  @articles = ArticleDecorator.decorate_collection(Article.all) # draper
end
```</p>

<p>Esse tipo de solução sempre me incomodou, e eu mantive minha busca por alguma que funcionasse de forma intrusiva, sem que fosse preciso modificar a chamada na action. E esta solução existe, chama-se <a href="https://github.com/amatsuda/active_decorator">active_decorator</a>.</p>

<p>O active_decorator <em>injeta</em> automaticamente o decorator em um model, ou em uma coleção de models ou uma instância do ActiveRecord::Relation a partir de um controller ou renderizando uma view com <code>:collection</code> ou <code>:object</code> ou <code>:local</code>. Sendo assim, não é preciso alterar nenhuma chamada no seu controller.</p>

<p>Vamos ver o exemplo anterior usando o active decorator.</p>

<p>```ruby</p>

<h1>any controller...</h1>

<p>def index
  @users = User.all
  @articles = Article.all
end
```</p>

<p>Existindo um <code>UserDecorator</code> e um <code>ArticleDecorator</code>, os objetos das coleções serão automaticamente <em>decorados</em> quando forem ser usados nas views.</p>

<p>Veja um exemplo mais completo:</p>

<p>```ruby</p>

<h1>any controller...</h1>

<p>def index
  @user = current_user
  @articles = current_user.articles
end</p>

<h1>user decorator</h1>

<p>module UserDecorator</p>

<p>  def full_name</p>

<pre><code>"#{first_name}-#{last_name}"
</code></pre>

<p>  end</p>

<p>end</p>

<h1>article decorator</h1>

<p>module ArticleDecorator</p>

<p>  def link_to_publish</p>

<pre><code>if published?
  "On air!"
else
  link_to "Publish", publish_article_path(self)
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>```erb</p>

<h1>app/views/articles/index.erb</h1>

<p>Olá &lt;%= @user.full_name %></p>

<ul>
<% @articles.each do |article| %>
  <li>
    <%= article.title %>
    <%= article.link_to_publish %>
  </li>
<% end %>
</ul>


<p>```</p>

<p>O active decorator é totalmente "plugável" a uma aplicação existente o que reduz bastante o esforço de implementação de decorators, facilitando a implementação gradual.</p>

<p>Abraços, <a href="http://twitter.com/rodrigoospinto">Rodrigo Pinto</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extraindo responsabilidade de um classe ruby utilizando polimorfismo]]></title>
    <link href="http://helabs.com.br/blog/2013/06/06/extraindo-responsabilidade-de-um-classe-ruby-que-sabe-demais-com-o-uso-de-polimorfismo/"/>
    <updated>2013-06-06T00:00:00-03:00</updated>
    <id>http://helabs.com.br/blog/2013/06/06/extraindo-responsabilidade-de-um-classe-ruby-que-sabe-demais-com-o-uso-de-polimorfismo</id>
    <content type="html"><![CDATA[<p>Já falei anteriormente um pouco sobre o uso do pattern decorator no rails <a href="http://helabs.com.br/blog/2013/01/28/extraindo-a-responsabilidade-de-fat-models-com-o-uso-de-decorators/">neste link</a>. Em algum momento a lógica pode ser tão complexa que quebraríamos os decorators em <em>decorators especializados</em>.</p>

<!--more-->


<p>Vamos a um exemplo: dado um <code>PostDecorator</code> com apenas um método público <code>show</code>, responsável por exibir um post, podemos reduzir a sua complexidade e manter a responsabilidade única de cada classe, baseando-se no tipo de status. Mas como?</p>

<p>```ruby
class PostDecorator</p>

<p>  def initialize(post)</p>

<pre><code>@post = post
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>if post.status == "draft"
  # ... lógica de draft aqui
elsif post.status == 'published'
  # ... lógica de published aqui
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>attr_reader :post
</code></pre>

<p>end
```</p>

<p>O primeiro passo que poderíamos fazer seria extrair a lógica de cada um dos status para classes especializadas, delegando as responsabilidades. Exemplo:</p>

<p>```ruby
class PostDecorator</p>

<p>  def initialize(post)</p>

<pre><code>@post = post
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>if post.status == "draft"
  PostDraftDecorator.new(post).show
elsif post.status == 'published'
  PostPublishedDecorator.new(post).show
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>attr_reader :post
</code></pre>

<p>end</p>

<p>class PostDraftDecorator</p>

<h1>... lógica de draft aqui</h1>

<p>end</p>

<p>class PostPublishedDecorator</p>

<h1>... lógica de published aqui</h1>

<p>end
```</p>

<p>Agora ficou melhor, já que a responsabilidade foi dividida.</p>

<p>Um outro pequeno refactory que poderíamos fazer é melhorar essa verificação de <code>if post.status == "draft"</code>. Podendo implementar em nosso model <code>Post#draft?</code> e <code>Post#published?</code>.</p>

<p>E assim, encapsulamos a lógica de <code>#draft?</code> e <code>#published?</code>, pois se a complexidade aumentar, teremos que mudar N contextos que fazem a verificação de tal lógica. Como agora elas estão encapsuladas, caso a lógica mude, teremos que alterar apenas no model.</p>

<p>```ruby
class PostDecorator</p>

<p>  def initialize(post)</p>

<pre><code>@post = post
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>if post.draft?
  PostDraftDecorator.new(post).show
elsif post.published?
  PostPublishedDecorator.new(post).show
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>attr_reader :post
</code></pre>

<p>end
```</p>

<p>Para evitarmos criar todos estes métodos na mão, podemos utilizar a <em>gem</em> <a href="https://github.com/maurogeorge/jacaranda">Jacaranda</a> que foi a minha primeira gem ;)</p>

<p>Mas ainda não é o melhor que podemos fazer para este caso. Vamos agora ao uso de polimorfismo:</p>

<h2>Resolvendo com o uso de polimorfismo</h2>

<p>Podemos usar <em>polimorfismo</em> para, dependendo do status do post, instanciar e utilizar o decorator correto.</p>

<p>```ruby
class PostDecorator</p>

<p>  def initialize(post)</p>

<pre><code>@post = post
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>post_decorator.new(post).show
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>attr_reader :post

def post_decorator
  "Post#{post.status.capitalize}Decorator".constantize
end
</code></pre>

<p>end
```</p>

<p>Como pode-se notar, criamos o método <code>post_decorator</code> que retorna a classe correta. Em seguida, instanciamos ela e chamamos o método <code>show</code> na classe específica.
Caso não seja de seu conhecimento, utilizamos o <a href="http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-constantize"><code>constantize</code></a> do ActiveSupport que nos retorna uma constante de mesmo nome baseado na string recebida.</p>

<p>Agora vamos aos testes do nosso <code>PostDecorator</code>:</p>

<p>```ruby
describe PostDecorator do</p>

<p>  let(:post_decorator) do</p>

<pre><code>PostDecorator.new(post)
</code></pre>

<p>  end</p>

<p>  describe "#show" do</p>

<pre><code>context "when post is a draft" do

  let!(:post) do
    Post.create(status: "draft")
  end

  it "call PostDraftDecorator" do
    post_draft_decorator = double("PostDraftDecorator")
    PostDraftDecorator.should_receive(:new).with(post).and_return(post_draft_decorator)
    post_draft_decorator.should_receive(:show)
    post_decorator.show
  end
end

context "when post is published" do

  let!(:post) do
    Post.create(status: "published")
  end

  it "call PostPublishedDecorator" do
    post_published_decorator = double("PostPublishedDecorator")
    PostPublishedDecorator.should_receive(:new).with(post).and_return(post_published_decorator)
    post_published_decorator.should_receive(:show)
    post_decorator.show
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Como visualiza-se acima, nossos testes ficaram bem simples. Testamos apenas se a delegação foi feita corretamente, pois a implementação seria testada unitariamente em cada uma das classes especializadas (<code>PostDraftDecorator</code> e <code>PostPublishedDecorator</code>).</p>

<h2>Conclusão</h2>

<p>Utilizando <em>polimorfismo</em>, agora nossa classe <code>PostDecorator</code> pode instanciar outros decorators e não precisaremos mais dos <em>ifs</em> e <em>elses</em>. Apenas crie uma nova classe como <code>PostUnpublishedDecorator</code> e todos os posts com o status <strong>unpublished</strong> usarão esta nova classe, pois segue-se a convenção.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Passwordless Login]]></title>
    <link href="http://helabs.com.br/blog/2013/04/11/passwordless-login/"/>
    <updated>2013-04-11T11:15:00-03:00</updated>
    <id>http://helabs.com.br/blog/2013/04/11/passwordless-login</id>
    <content type="html"><![CDATA[<p><img src="/images/posts/passwordless.png" alt="image" /></p>

<p>Neste post, vou mostrar como fazer uma aplicação permitir que o usuário faça login sem precisar digitar/lembrar de sua senha. Não será nada complexo demais e nem uma solução perfeita. No final, postarei o link para uma aplicação exemplo que preparei exemplificando o método.</p>

<h1>Por que fazer login sem senha?</h1>

<p>Fazer login está se tornando uma tarefa complicada. Agora que temos muitos usuários acessando aplicações pelo smartphone, digitar a senha na telinha do telefone é complicado. Mesmo nas telas gigantes dos celulares da Samsung, é chato e ruim. Precisamos de uma maneira mais simples de fazê-lo.</p>

<!-- more -->


<p>Os usuários têm que lembrar seu username e senha para logarem. Mas muitas vezes não os lembram. E é aí que entra o “esqueci minha senha” e o usuário precisa abrir seu email e clicar no link para poder recuperar sua senha. Ou então para que a senha não seja esquecida eles usam: password, senha123 ou 123456.</p>

<p>Uma solução proposta por Ben Brown neste <a href="http://notes.xoxco.com/post/27999787765/is-it-time-for-password-less-login">post</a> é gerar uma senha totalmente aleatória quando o usuário se cadastrar no site e enviar por email um link para fazer o login. A maioria dos sites permitem que o login seja mantido pra sempre, porém se o usuário precisar fazer o login novamente, a aplicação gera outra senha para o usuário e envia outro link para ele por email.</p>

<h1>Como eu resolvi esse problema</h1>

<p>Então vamos ao código:</p>

<p>Primeiro, criei um model User com os campos <em>email</em> e <em>access_token</em>.</p>

<p><code>ruby
rails g model User email:string access_token:string
</code></p>

<p>Depois, criei um método <em>generate_access_token </em>que se encarrega de gerar uma nova senha para o usuário. E também o método <em>access_token_exists? </em>(token) para checar se, por acaso, a senha já existe para algum usuário.</p>

<p>```ruby
def self.access_token_exists?(token)
  where(access_token: token).any?
end</p>

<p>private
  def generate_access_token</p>

<pre><code>loop do
  token = SecureRandom.hex(30)
  return self.access_token = token unless User.access_token_exists?(token)
end
</code></pre>

<p>  end
```</p>

<p>E então implementei o método <em>generate_access_token_and_save </em>para gerar a senha para o usuário e salvá-la. Isso fecha por enquanto o model User. Voltaremos nele mais tarde.</p>

<p><code>ruby
def generate_access_token_and_save
  generate_access_token and save
end
</code></p>

<p>Agora vamos ao <em>UsersController </em>. Criei um controller simples com duas actions: New e Create.</p>

<p>```ruby</p>

<h1>encoding: UTF-8</h1>

<p>class UsersController &lt; ApplicationController
  def new</p>

<pre><code>@user = User.new
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>@user = User.new(params[:user])
if @user.generate_access_token_and_save
  redirect_to new_user_path, notice: "Agora olha teu email lá! :)"
else
  render :new
end
</code></pre>

<p>  end
end
```</p>

<p>Em seguida, criei o SessionsController para lidar com o login. O controller vai encontrar o usuário que possua a access_token fornecida e colocar seu id em uma session.</p>

<p>```ruby</p>

<h1>encoding: UTF-8</h1>

<p>class SessionsController &lt; ApplicationController
  def create</p>

<pre><code>user = User.find_by_access_token!(params[:token])
session[:user_id] = user.id
redirect_to(secret_page_path, notice: "Você está logado! :)")
</code></pre>

<p>  rescue ActiveRecord::RecordNotFound</p>

<pre><code>redirect_to(root_url, notice: "Acesso inválido... recupere sua senha.")
</code></pre>

<p>  end
end
```</p>

<p>Agora que já tenho o controller para lidar com o link de login, posso criar o Mailer para enviar o link para o email do usuário.</p>

<p>```ruby</p>

<h1>encoding: UTF-8</h1>

<p>class Notification &lt; ActionMailer::Base
  default from: "estagiario@passwordlessapp.com"
  layout "mailer"</p>

<p>  def auth_link(user)</p>

<pre><code>@user = user

mail to: @user.email, subject: "[Passwordless App] Aqui está seu link de acesso"
</code></pre>

<p>  end
end
```</p>

<p>Coloquei, então, a chamada para o envio do email dentro do método <em>generate_access_token_and_save </em>no model User.</p>

<p><code>ruby
def generate_access_token_and_save
  Notification.auth_link(self).deliver if generate_access_token and save
end
</code></p>

<p>Usei o SecretPageController para ter uma action que requer autenticação.</p>

<p>```ruby
class SecretController &lt; ApplicationController
  before_filter :authenticate!</p>

<p>  def index
  end
end
```</p>

<p>Aqui estão os helpers de autenticação criados para o SecretPageController.</p>

<p>```ruby</p>

<h1>encoding: UTF-8</h1>

<p>class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  ensure_security_headers
  helper_method :current_user, :user_signed_in?</p>

<p>  private</p>

<p>  def current_user</p>

<pre><code>@current_user ||= User.find(session[:user_id]) if session[:user_id]
rescue ActiveRecord::RecordNotFound
  session.delete(:user_id)
  nil
</code></pre>

<p>  end</p>

<p>  def user_signed_in?</p>

<pre><code>!current_user.nil?
</code></pre>

<p>  end</p>

<p>  def authenticate!</p>

<pre><code>user_signed_in? || redirect_to(root_url, notice: "Você precisa estar autenticado...")
</code></pre>

<p>  end
end
```</p>

<p>E isso já faz o login sem senha funcionar. O usuário se cadastra, recebe um link por email, clica no link, se loga e é redirecionado para a action que requer autenticação.</p>

<p>Eu fiz uma aplicação exemplo que pode ser acessada <a href="http://passwordless.herokuapp.com">clicando aqui</a> e o código também está no <a href="https://github.com/matheusbras/passwordless-app">GitHub</a> com todos os testes. Sintam-se à vontade para mandar pull requests, issues e perguntas.</p>

<p>Obrigado pela sua atenção e abraços!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scoped route com a gem friendly_id]]></title>
    <link href="http://helabs.com.br/blog/2013/02/26/scoped-route-com-a-gem-friendly-id/"/>
    <updated>2013-02-26T11:00:00-03:00</updated>
    <id>http://helabs.com.br/blog/2013/02/26/scoped-route-com-a-gem-friendly-id</id>
    <content type="html"><![CDATA[<p>Quando participei do desenvolvimento do projeto <a href="http://clubedomenu.com">clubedomenu.com</a>, um sistema voltado para delivery de comida, foi feito pensando exclusivamente para a cidade de Londrina.
Recentemente surgiu a necessidade de expandir o sistema para outras localidades.
Feito um estudo das funcionalidades existentes.</p>

<!-- more -->


<p>Foi visto que as urls do sistema foram contruídas dessa forma:</p>

<p><code>
clubedomenu.com/nome_do_restaurante
</code></p>

<p>Agora é preciso que a url seja montada dessa forma, para distinguir os restaurantes por cidade:</p>

<p><code>
clubedomenu.com.br/nome_da_cidade/nome_do_restaurante
</code></p>

<p>Além disso pode acontecer casos onde 2 restaurantes em diferentes cidades com o mesmo slug nome_do_restaurante. Como isso pode acontecer? Muito simples, basta a mesma empresa ter uma matriz e uma filial com o mesmo nome em cidades diferentes.</p>

<p>Desde o começo do projeto foi adotado a gem <a href="https://github.com/norman/friendly_id">friendly_id</a> que transforma as urls em uma forma mais amigável.</p>

<p>Para resolver o problema de franquia de restaurantes em cidades diferentes com o mesmo slug a gem oferece essa solução:</p>

<p><code>ruby
friendly_id :nome_do_campo_restaurante, :use =&gt; :scoped, :scope =&gt; :nome_do_campo_cidade.
validates_uniqueness_of :nome_do_campo_restaurante, :scope =&gt; :city
</code></p>

<p>Dessa forma é possível obter urls assim.</p>

<p><code>
clubedomenu.com.br/nome_da_cidade_1/nome_do_restaurante
clubedomenu.com.br/nome_da_cidade_2/nome_do_restaurante
</code></p>

<p>Aqui está um teste que prova que é possível ter subdomínios iguais em cidades diferentes.</p>

<p>```ruby
describe "scoped city" do</p>

<pre><code>let!(:restaurant_1) { FactoryGirl.create(:restaurant, name: "Pizzaria Boa", city: "Maringa", subdomain: "veneza") }
let!(:restaurant_2) { FactoryGirl.create(:restaurant, name: "Pizzaria Boa", city: "Londrina", subdomain: "veneza") }
it "should repeat slug scoped by city", :vcr do
  restaurant_1.to_param.should eq("veneza")
  restaurant_2.to_param.should eq("veneza")
end
</code></pre>

<p>end
```</p>

<p>Twitter <a href="http://twitter.com/reginato">@reginato</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testes (bem) mais rápidos no RSpec]]></title>
    <link href="http://helabs.com.br/blog/2013/02/06/testes-mais-rapidos-no-rspec/"/>
    <updated>2013-02-06T15:45:00-02:00</updated>
    <id>http://helabs.com.br/blog/2013/02/06/testes-mais-rapidos-no-rspec</id>
    <content type="html"><![CDATA[<p>Conforme um projeto vai crescendo, a quantidade de casos de teste aumenta e a tendência é que a suíte completa comece a demorar mais para rodar, principalmente se você está fazendo testes de aceitação. Isso pode virar um problema muito grave em projetos legados, mas existem soluções rápidas (a.k.a marretas) que resolvem esse problema. Vou mostrar neste post como fiz para <strong>reduzir em mais de 70% o tempo de execução da suíte de testes</strong> de um projeto.</p>

<!-- more -->


<p>Se você está começando um projeto novo, eu sugiro seguir as <a href="http://simplesideias.com.br/fazendo-os-seus-testes-executarem-mais-rapido">recomendação do Nando Vieira</a>, que incluem decisões de como escrever o código de forma limpa, e que não vão criar gargalos para os testes.</p>

<p>No meu caso o buraco era mais embaixo e eu precisava de algo antes de sair refatorando tudo. Eu estava trabalhando num projeto Rails que possui um pouco menos de 8.000 linhas de código e um pouco mais de 30.000 linhas de teste, um Code to Test Ratio de 1:3.9 e mais de 5.000 testes.
Tanto o código quanto os testes precisavam de melhorias e a suíte estava demorando cerca de <strong>13 minutos para rodar</strong>. Tempo que qualquer um sabe que é ridiculamente alto e inviável para se trabalhar.</p>

<p>```
rake</p>

<p>Finished in 13 minutes 27.67 seconds
5162 examples, 0 failures, 16 pending
```</p>

<p>Eu precisava refatorar os testes, mas também o código e isso exigia um tempo de trabalho considerável.
Eu praticamente tinha um problema de "referência circular", ou <a href="http://www.youtube.com/watch?v=tJ-BKu-WUEk">efeito Tostines</a>. Eu precisava refatorar para ter os testes mais rápidos, mas também precisava dos testes mais rápidos para poder trabalhar e conseguir refatorar.</p>

<p>Enfim, uma situação desconfortável e que iria demandar paciência e um bocado de trabalho, principalmente no início.
Não havia mágica para resolver de uma vez, então eu comecei a buscar soluções que diminuíssem a dor do momento.</p>

<p>O resultado foi que <strong>reduzi o tempo de execução dos testes de 13 minutos para 4 minutos</strong>, sem refatorar o código e mexendo muito pouco nos testes. Eu sei que 4 minutos ainda é muito e tem que melhorar, mas para a realidade do momento, já estava ótimo!</p>

<p>Seguem as dicas do que eu fiz com as referências. As duas primeiras eu retirei do <a href="http://blog.plataformatec.com.br/2011/12/three-tips-to-improve-the-performance-of-your-test-suite/">post do José Valim</a></p>

<h3>Dica 1: Shared Connections</h3>

<p>O meu projeto tem testes de aceitação usando <a href="https://github.com/jnicklas/capybara">capybara</a> e <a href="https://github.com/thoughtbot/capybara-webkit">capybara-webkit</a> e eu usava a gem <a href="https://github.com/bmabey/database_cleaner">database_cleaner</a> para limpar o banco de dados entre um teste e outro, como sugerido pelo próprio Capybara.</p>

<p>O problema é que o database cleaner torna a suíte muito lenta, por que a todo momento ele está acessando o banco de dados para limpar a base toda. A solução é fazer uma marreta no ActiveRecord para que o database cleaner não seja mais necessário.</p>

<p>Removi o database cleaner e voltei a configuração <code>use_transactional_fixtures</code> pra <code>true</code></p>

<p>```ruby</p>

<h1>spec/spec_helper.rb</h1>

<p>RSpec.configure do |config|
  [...]</p>

<p>  config.use_transactional_fixtures = true
end
```</p>

<p>Adicionei o código abaixo:</p>

<p>```ruby</p>

<h1>spec/support/shared_connection.rb</h1>

<p>class ActiveRecord::Base
  mattr_accessor :shared_connection
  @@shared_connection = nil</p>

<p>  def self.connection</p>

<pre><code>@@shared_connection || retrieve_connection
</code></pre>

<p>  end
end</p>

<h1>Forces all threads to share the same connection. This works on</h1>

<h1>Capybara because it starts the web server in a thread.</h1>

<p>ActiveRecord::Base.shared_connection = ActiveRecord::Base.connection
```</p>

<p>Esse código faz com que o ActiveRecord compartilhe a mesma conexão com o banco de dados em todas as threads. Na prática os testes do Capybara acabam rodando dentro de uma transação, então qualquer modificação no banco de dados não é comitada e é descartada a cada teste.</p>

<h3>Dica 2: Increase Log Level</h3>

<p>Por default o Rails grava log de tudo que acontece no environment <code>test</code>. Isso faz com que o acesso à disco seja muito alto, o que torna a execução dos testes mais lenta. Aumentando o nível do log você reduz o IO durante os testes. Para isso, adicionei o código abaixo:</p>

<p>```ruby</p>

<h1>spec/support/suppress_log.rb</h1>

<p>Rails.logger.level = 4 unless ENV['WITH_LOG']
```</p>

<p>Se você quiser que o log seja gravado, basta setar a variável de ambiente <code>WITH_LOG</code> para true.</p>

<p><code>bash
$ WITH_LOG=true rake
</code></p>

<h3>Dica 3: Deferred Garbage Collection</h3>

<p>Quando os testes rodam, muitas variáveis são criadas na memória, o que consome muita memória e faz com que o Garbage Collector seja chamado diversas vezes. Se zerarmos as variáveis de instância e controlarmos "na mão" o Garbage Collector, conseguimos um ganho de performance bastante significativo.</p>

<p>Misturando <a href="http://37signals.com/svn/posts/2742-the-road-to-faster-tests">isso</a> com <a href="https://makandracards.com/makandra/950-speed-up-rspec-by-deferring-garbage-collection">isso</a> eu escrevi e adicionei o código abaixo:</p>

<p>```ruby</p>

<h1>spec/support/deferred_garbage_collection.rb</h1>

<p>class DeferredGarbageCollection
  RESERVED_IVARS = %w(@loaded_fixtures)
  DEFERRED_GC_THRESHOLD = (ENV['DEFER_GC'] || 10.0).to_f
  @@last_gc_run = Time.now
  def self.start</p>

<pre><code>GC.disable if DEFERRED_GC_THRESHOLD &gt; 0
</code></pre>

<p>  end
  def self.reconsider</p>

<pre><code>if DEFERRED_GC_THRESHOLD &gt; 0 &amp;&amp; Time.now - @@last_gc_run &gt;= DEFERRED_GC_THRESHOLD
  GC.enable
  GC.start
  GC.disable
  @@last_gc_run = Time.now
end
</code></pre>

<p>  end
end</p>

<p>RSpec.configure do |config|
  config.before(:all) do</p>

<pre><code>DeferredGarbageCollection.start
</code></pre>

<p>  end
  config.after(:each) do
   (instance_variables - DeferredGarbageCollection::RESERVED_IVARS).each do |ivar|</p>

<pre><code> instance_variable_set(ivar, nil)
</code></pre>

<p>   end
  end
  config.after(:all) do</p>

<pre><code>DeferredGarbageCollection.reconsider
</code></pre>

<p>  end
end
```</p>

<h3>Resultado: Ganho de 45% de tempo</h3>

<p>Com as implementações acima já consegui ganhar 6 minutos!</p>

<p><code>
rake
Finished in 7 minutes 27.48 seconds
5161 examples, 0 failures, 16 pending
</code></p>

<p>(sim, eu removi um teste nesse meio tempo)</p>

<h3>Dica 4: Parallel Tests</h3>

<p>Um outro artifício que, não faz com que os testes rodem mais rápidos efetivamente, mas faz com você perca menos tempo ao rodar a suíte, é paralelizar os testes. A gem responsável por isso é a <a href="https://github.com/grosser/parallel_tests">parallel_tests</a></p>

<p>Para instalar a gem, basta colocar a linha abaixo no Gemfile:</p>

<p>```ruby</p>

<h1>add to Gemfile</h1>

<p>gem "parallel_tests", :group => :development
```</p>

<p>Eu deixei o parallel tests como opção default do rake, incluindo a seguinte rake task:</p>

<p>```ruby</p>

<h1>lib/tasks/default.rake</h1>

<p>task(:default).clear
task :default  => "parallel:spec"
```</p>

<p>BTW eu fiz um <a href="https://github.com/rafaelp/guard-rspec/commit/7bfdd649e85d3700716be2fd43277c10aa6cb8df">commit no guard-rspec</a> para ele suportar o parallel tests.</p>

<p>Rodando os testes em paralelo, você aproveita o máximo que da CPU, mas também consome muita bateria. Não recomendado se você estiver trabalhando durante um vôo, por exemplo :)</p>

<h3>Resultado: Testes rodando em menos de 5 minutos</h3>

<p>```
rake</p>

<p>Results:
1545 examples, 0 failures, 10 pending
1188 examples, 0 failures, 3 pending
1292 examples, 0 failures, 2 pending
1138 examples, 0 failures, 1 pending</p>

<p>Took 272.119908 seconds
```</p>

<p>Os testes rodando em paralelo demoraram 4 minutos e 53 segundos e isso é um ganho incrível comparado com os 13 minutos iniciais. Críticos de plantão, eu sei que 4 minutos e pouco ainda é bastante e que dá pra melhorar ;-)</p>

<h3>Dica 5: Ruby Patch railsexpress</h3>

<p>Existe um patch para as versões 1.8.7, 1.9.2 e 1.9.3 do Ruby que diminui o tempo de load do Rails e de execução dos testes.</p>

<p>Para usar é muito fácil.</p>

<p>Se você estiver no Mac OS, instale o automake:</p>

<p><code>bash
brew install automake
</code></p>

<p>Agora rode o comando abaixo:</p>

<p><code>bash
rvm reinstall 1.9.3 --patch railsexpress
</code>
(substitua 1.9.3 pela versão do ruby que você está usando)</p>

<p>Depois defina duas variáveis de ambiente:</p>

<p>```bash</p>

<h1>add to .bash_profile</h1>

<p>export RUBY_GC_MALLOC_LIMIT=60000000
export RUBY_FREE_MIN=200000
```</p>

<p>Pronto!</p>

<p>Se quiser ler mais sobre isso:</p>

<p><a href="https://gist.github.com/4136519">https://gist.github.com/4136519</a></p>

<p><a href="https://github.com/skaes/rvm-patchsets">https://github.com/skaes/rvm-patchsets</a></p>

<p><a href="https://github.com/wayneeseguin/rvm/tree/master/patches/ruby/1.9.3/p374/railsexpress">https://github.com/wayneeseguin/rvm/tree/master/patches/ruby/1.9.3/p374/railsexpress</a></p>

<h3>Resultado Final: Ganho de mais de 70% de tempo</h3>

<p>Quando eu instalei esse patch do Rails, eu já tinha 203 testes a mais escritos no projeto e a suíte estava demorando 322.394261 segundos rodando em parelelo. Ou seja, mais tempo do que o benchmark anteior. Após aplicar o patch esse tempo diminuiu para 245.99421 segundos, menos tempo que o benchmark anterior!</p>

<p>```
rake</p>

<p>5366 examples, 0 failures, 9 pendings
Took 245.99421 seconds
```</p>

<p>Com esses resultados, posso afirmar que o ganho de tempo total para o meu projeto foi superior a 70%.
Nada mal, sair de 13 minutos para 4 minutos, não acha!?</p>

<h3>Bônus: Guard + Zeus</h3>

<p>Quando eu estou programando, não fico rodando os testes todos, até por que 4 minutos ainda é inviável para fazer TDD. Para resolver ese problema comecei a usar o <a href="https://github.com/guard/guard-rspec">guard-rspec</a> com <a href="https://github.com/burke/zeus">zeus</a> e <a href="https://www.relishapp.com/rspec/rspec-core/v/2-4/docs/command-line/tag-option">tags do RSpec</a>.</p>

<p>O guard é responsável por monitorar as mudanças nos arquivos e rodar testes específicos que são relativos ao arquivo alterado. O guard-rspec é uma gem que se encarrega de chamar o rspec com os parâmteros corretos para que isso aconteça.</p>

<p>O zeus é um aplicativo que pré carrega o stack do Rails na memória e quando você roda os comandos que precisam do environment do Rails, ele busca o que já está carregado na memória.</p>

<p>As tags do RSpec permitem que você defina uma ou mais tags em um teste e passe um parâmetro na linha de comando <code>rspec</code> para que somente os testes com aquela tag sejam rodados.</p>

<p>Instalando o zeus:</p>

<p><code>
gem install zeus
</code></p>

<p>Instalando o guard-spec:</p>

<p>```ruby</p>

<h1>add to Gemfile</h1>

<p>gem "guard-rspec", :group => :development
```</p>

<p>Meu Guadfile, arquivo de configuração do guard para o projeto:</p>

<p>```ruby</p>

<h1>Guadfile</h1>

<p>notification :growl</p>

<p>guard 'rspec', :cli => "--tag focus --color --fail-fast", :all_after_pass => false, :all_on_start => false, :zeus => true, :parallel => false do
  watch('spec/spec_helper.rb')                        { "spec" }
  watch('config/routes.rb')                           { "spec/routing" }
  watch('app/controllers/application_controller.rb')  { "spec/controllers" }
  watch(%r{<sup>spec/.+_spec.rb$})</sup>
  watch(%r{<sup>app/(.+).rb$})</sup>                           { |m| "spec/#{m[1]}<em>spec.rb" }
  watch(%r{<sup>app/(.*)(.erb|.haml)$})</sup>                 { |m| "spec/#{m[1]}#{m[2]}</em>spec.rb" }
  watch(%r{<sup>lib/(.+).rb$})</sup>                           { |m| "spec/lib/#{m[1]}<em>spec.rb" }
  watch(%r{<sup>app/controllers/(.+)_(controller).rb$})</sup>  { |m| ["spec/routing/#{m[1]}</em>routing_spec.rb", "spec/#{m[2]}s/#{m[1]}<em>#{m[2]}</em>spec.rb", "spec/acceptance/#{m[1]}_spec.rb"] }</p>

<p>  # Rspec support
  watch(%r{<sup>spec/support/(.+).rb$})</sup>                  { "spec" }</p>

<p>  # Blueprints
  watch(%r{<sup>spec/blueprints.rb$})</sup>                    { "spec" }</p>

<p>  # Capybara
  watch(%r{<sup>spec/acceptance/(.+).rb$})</sup>
end
```</p>

<p>Agora basta abrir duas janelas do terminal e deixar uma rodando o zeus e outra o guard:</p>

<p><code>bash
$ zeus start
</code></p>

<p><code>bash
$ guard start
</code></p>

<p>No meu ciclo de TDD, eu deixo o guard testando automaticamente os arquivos que ele detecta que foram modificados. Em algums momentos eu quero validar apenas um teste, e é muito chato ter que esperar todos os testes do arquivo que estou trabalhando, todas as vezes que eu o salvo.</p>

<p>Você pode perceber que no meu Guarfile eu passo o parâmetro <code>--tag focus</code> para o rspec. Isso faz com que ele rode apenas os testes com a tag <code>focus</code>. Quando nenhum teste possui essa tag, ele roda todos os testes do arquivo.</p>

<p>Como eu também passo o parâmetro <code>--fail-fast</code>, o rspec pára no primeiro teste que quebra.</p>

<p>Quando estou escrevendo um teste novo em um arquivo com muitos testes ou quando um dos testes quebra, eu coloco a tag <code>focus</code> no teste em questão, ou no contexto inteiro dele. A partir daí o guard roda somente este teste a cada vez que eu salvo o arquivo. Isso agiliza muito o meu trabalho, pois não preciso esperar todos os testes do arquivo serem rodados, ou seja, os testes que eu quero validar são executados de imediato.</p>

<p>Para colocar a tag, basta passar um hash <code>{focus: true}</code> como segundo parâmetro do <code>describe</code>, do <code>context</code> ou do <code>it</code>. Veja um exemplo de como colocar essa tag:</p>

<p>```ruby
describe "welcome" do
  let(:account) { Account.make }
  let(:mailer) { AccountMailer.welcome(account) }
  it { expect { mailer }.not_to raise_error }
  it { expect { mailer.deliver }.not_to raise_error }
  it { expect { mailer.deliver }.to change(ActionMailer::Base.deliveries,:size).by(1) }
  context "mailer", focus: true do</p>

<pre><code>it { mailer.subject.should == "Muito obrigado por estar conosco" }
it { mailer.header['From'].to_s.should == "Suporte &lt;suporte@example.com&gt;" }
it { mailer.header['To'].to_s.should == "Nome do Usuario &lt;emaildousuario@example.com&gt;" }
it { mailer.from.size.should == 1 }
it { mailer.to.size.should == 1 }
it { mailer.cc.should be_nil }
it { mailer.bcc.should be_nil }
it { mailer.multipart?.should be_false }
it { mailer.charset.should == "UTF-8" }
it { mailer.content_type.should == "text/html; charset=UTF-8" }
</code></pre>

<p>  end
end
```</p>

<h3>Conclusão</h3>

<p>Mesmo com problemas no código e testes mal escritos eu consegui reduzir o tempo de execução da suíte e criar um fluxo de trabalho que me permitiu fazer TDD e trabalhar para refatorar tudo, sem perder muito tempo no início. Na prática isso viabilizou a continuidade do trabalho e diminuiu significativamente a dor de ter uma suíte lenta. Uma suíte de testes lenta é um perigo por que nos leva a não querer rodar os testes e ignorar TDD.</p>

<p>Ainda tenho um bom caminho pela frente para melhorar o código atual, mas chegou num nível que já consigo refatorar o que existe em paralelo com desenvolver novas features.</p>

<p>Se uma das dicas já for algo útil pra você, ficarei feliz! Fique a vontade para dar o seu feedback nos comentários ou falar comigo pelo twitter <a href="https://twitter.com/rafaelp">@rafaelp</a></p>

<p>Abraços e até a próxima.</p>
]]></content>
  </entry>
  
</feed>
