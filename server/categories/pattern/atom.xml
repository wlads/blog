<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Pattern | Blog da HE:labs]]></title>
  <link href="http://helabs.com.br/blog/categories/pattern/atom.xml" rel="self"/>
  <link href="http://helabs.com.br/blog/"/>
  <updated>2013-08-30T10:44:41-03:00</updated>
  <id>http://helabs.com.br/blog/</id>
  <author>
    <name><![CDATA[Time HE:labs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remova Ifs e Elses em Ruby utilizando o Null Object Pattern]]></title>
    <link href="http://helabs.com.br/blog/2013/04/07/remova-ifs-e-elses-em-ruby-utilizando-o-null-object-pattern/"/>
    <updated>2013-04-07T11:16:00-03:00</updated>
    <id>http://helabs.com.br/blog/2013/04/07/remova-ifs-e-elses-em-ruby-utilizando-o-null-object-pattern</id>
    <content type="html"><![CDATA[<p>O <a href="https://en.wikipedia.org/wiki/Null_object">Null Object pattern</a> tem como principal objetivo tratar o comportamento do valor <code>Null</code>, ou em ruby o <code>nil</code>.
Sabemos que em algum momento de nosso código podemos ter referências nulas, sendo assim, temos que verificar se tal refêrencia é nula ou não para não recebermos uma <em>exception</em> como a seguinte:</p>

<pre><code>NoMethodError: undefined method `name' for nil:NilClass
</code></pre>

<!-- more -->


<p>Vamos a um exemplo: Temos uma classe Game responsável pelas informações de um dado jogo e um classe Report, responsável por imprimir os dados deste tal jogo.</p>

<p>Vamos a classe Game:</p>

<p>```ruby
require 'ostruct'</p>

<p>class Game &lt; OpenStruct
end
```</p>

<p>Uma simples classe que herda de OpenStruct.</p>

<p>Agora vamos a nossa classe Report:</p>

<p>```ruby
class Report</p>

<p>  def initialize(game)</p>

<pre><code>@game = game
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>%Q{Game: #{name}
Platform: #{platform}
Description: #{description}}
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def name
  @game.name
end

def platform
  @game.platform
end

def description
  @game.description
end
</code></pre>

<p>end
```</p>

<p>Como podem ver, a nossa classe funciona muito bem para o Game. No entanto, se em algum momento recebermos uma referência nula (por exemplo de um find do ActiveRecord),  receberemos a seguinte exception:</p>

<p><code>ruby
game = nil
report = Report.new(game)
puts report.show # undefined method `name' for nil:NilClass (NoMethodError) ...
</code></p>

<p>Vamos resolvê-la utilizando os mais comuns: <code>if</code> e <code>else</code>.</p>

<p>```ruby
class Report</p>

<p>  def initialize(game)</p>

<pre><code>@game = game
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>%Q{Game: #{name}
Platform: #{platform}
Description: #{description}}
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def name
  if @game
    @game.name
  else
   'no name'
  end
end

def platform
  if @game
    @game.platform
  else
    'no platform'
  end
end

def description
  if @game
    @game.description
  else
    'no description'
  end
end
</code></pre>

<p>end
```</p>

<p>Como podem ver, alteramos os métodos da classe <code>Report</code>, responsável por criar os campos de <code>Game</code> na exibição do relatório, para tratar quando recebemos um valor nil.
Até funciona, mas como notamos, estamos adicionando mais complexidade a simples métodos que apenas delegam o valor, além de, claramente, estarmos repetindo código. E é neste ponto que o Null Object Pattern vem para nos ajudar. Vamos aos refactories.</p>

<p>```ruby
class NullGame</p>

<p>  def name</p>

<pre><code>'no name'
</code></pre>

<p>  end</p>

<p>  def platform</p>

<pre><code>'no platform'
</code></pre>

<p>  end</p>

<p>  def description</p>

<pre><code>'no description'
</code></pre>

<p>  end
end</p>

<p>class Report</p>

<p>  def initialize(game)</p>

<pre><code>@game = game || NullGame.new
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>%Q{Game: #{name}
Platform: #{platform}
Description: #{description}}
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def name
  @game.name
end

def platform
  @game.platform
end

def description
  @game.description
end
</code></pre>

<p>end
```</p>

<p>Primeiro criamos uma classe <code>NullGame</code> responsável por definir os valores quando um <code>Game</code> for nulo. Em Seguida, alteramos a classe <code>Report</code> para instanciar um <code>NullGame</code> (caso o game seja nulo) e assim, podemos alterar nossos métodos que funcionam como delegators para continuarem fazendo apenas isto.
Veja como seria o comportamento de <code>Report</code> ao receber um <code>nil</code>:</p>

<p>```ruby
game = nil
report = Report.new(game)
puts report.show # Game: no name</p>

<pre><code>             # Platform: no platform
             # Description: no description
</code></pre>

<p>```</p>

<p>Como podem ver, ao utilizarmos o Null Object Pattern, conseguimos manter o nosso código muito mais Ruby Way utilizando classes coesas, com responsabilidades bem definidas e one line methods.</p>

<p>Para finalizar fica a dica da excelente palestra do <a href="https://twitter.com/@r00k">Ben Orenstein</a> <a href="http://www.confreaks.com/videos/1233-aloharuby2012-refactoring-from-good-to-great">Refactoring from Good to Great</a> , de onde este post foi inspirado.</p>
]]></content>
  </entry>
  
</feed>
