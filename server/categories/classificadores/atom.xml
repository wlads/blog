<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: classificadores | Blog da HE:labs]]></title>
  <link href="http://helabs.com.br/blog/categories/classificadores/atom.xml" rel="self"/>
  <link href="http://helabs.com.br/blog/"/>
  <updated>2013-08-30T10:44:41-03:00</updated>
  <id>http://helabs.com.br/blog/</id>
  <author>
    <name><![CDATA[Time HE:labs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[E se usarmos Machine Learning para resolver problemas]]></title>
    <link href="http://helabs.com.br/blog/2013/02/04/e-se-usarmos-machine-learning-para-resolver-problemas/"/>
    <updated>2013-02-04T14:00:00-02:00</updated>
    <id>http://helabs.com.br/blog/2013/02/04/e-se-usarmos-machine-learning-para-resolver-problemas</id>
    <content type="html"><![CDATA[<p>Para mim, uma das coisas mais interessantes no meio de desenvolvimento de softwares é a que não existe apenas uma forma de se fazer. Existem diversas formas corretas (e incorretas) de se resolver algum problema. Elas vão do incrivelmente simples à forma mais rebuscada ou a mais marretada.
Geralmente, quando posso, escolho a forma mais divertida.</p>

<!-- more -->


<p><img src="/images/posts/2013-02-04/dr-evil.jpg" alt="image" /></p>

<blockquote><p><strong>Number Two:</strong> <em>Why not use your knowledge of the future to play the stock markets? We could make trillions.</em></p>

<p><strong>Dr. Evil:</strong> <em>Why make a trillion when we could make... billions?'</em></p></blockquote>

<p>Certa vez conheci um cliente com um problema interessante.
Ele tinha uma tabela com uma série de prefixos de telefone contendo o código do pais mais código de área mais os primeiros números do telefone, o suficiente para diferenciar um de outro. O código de área era opcional bem como a quantidade de números de telefone.
Para cada prefixo, uma taxa especifica.</p>

<hr />

<p>Ex:</p>

<ul>
<li><strong>prefix</strong> ---- <strong>rate</strong></li>
<li>551198 ----  0.025</li>
<li>55119 ----   0.015</li>
<li>55118 ----   0.025</li>
<li>55113 ----   0.01</li>
<li>55112 ----   0.012</li>
<li>52199 ----   0.03</li>
<li>55218 ----   0.025</li>
<li>55213 ----   0.011</li>
<li>55212 ----   0.013</li>
<li>240 ----     0.50</li>
</ul>


<hr />

<p>O principal problema consistia no fato de não saber que parte da string que continha o número era de fato o prefixo e o que era o número, pois recebíamos o número como uma string inteira, por exemplo: “5511980000000”.</p>

<p>E como qualquer outro problema, existem diversas maneiras de se resolver.</p>

<p>Sempre fui fascinado por <a href="http://en.wikipedia.org/wiki/Machine_learning">Machine Learning</a>. Na realidade, desde a época que eu não sabia direito o que significava mas já sabia que ele foi muito mal implementado no Exterminador do Futuro 1<a href="#1">¹</a>. Vi aí uma oportunidade de me divertir, mesmo que a solução não viesse a ser usada.</p>

<p><img src="/images/posts/2013-02-04/sarahconnor.png" alt="image" /></p>

<p>Caso não saiba o que é Machine Learning e para que serve, vamos para o Wikipédia:</p>

<blockquote><p>“Machine learning, a branch of artificial intelligence, is about the construction and study of systems that can learn from data.”
--- <cite>Wikipédia</cite></p></blockquote>

<p>Era exatamente o que eu estava procurando. Não queria pensar em um algoritmo que fizesse isso por mim. Vou deixar o próprio computador aprender com os dados e decidir o valor correto.</p>

<p>Um dos ramos do Machine Learning é a classificação. Acredito que é a parte mais simples de se explicar e ver como funciona.</p>

<p>Existem, atualmente, diversos algoritmos que conseguem cobrir virtualmente qualquer situação. Para esse exemplo usarei o <a href="http://en.wikipedia.org/wiki/ID3_algorithm">ID3</a> e como o Ruby ainda não tem uma grande variedade de bibliotecas de Machine Learning, usarei a que acredito ser a mais famosa: <a href="http://ai4r.org/">AI4r</a>.</p>

<p><code>
gem install ai4r
</code></p>

<p>O próximo passo seria obter o dataset. Fiz um collect da tabela com os campos necessários para nossa pesquisa (no nosso caso, apenas prefix e rate). O Ai4r leva em conta todos os valores que adicionamos no array, sendo que o último elemento da array seria o valor que estamos buscando.
Caso você esteja lendo esse blog do futuro, provavelmente já estará usando o rails 4 ou superior, onde o active record pode fazer o pluck com múltiplos valores. E eu os invejo.</p>

<p><code>ruby
def dataset
   data = NumberPattern.collect{|d| [d.prefix, d.rate]}
   label = ['prefix', 'rate']
   Ai4r::Data::DataSet.new(data_items: data, data_labels: label)
end
</code></p>

<p>Agora com nosso dataset preparado, basta adicionar água, digo, a biblioteca de classificação ID3. É um algoritmo nem tão complicado mas que foge ao escopo desse texto.</p>

<p><code>
@a = Ai4r::Classifiers::ID3.new.build dataset
</code></p>

<p>Agora começa a magica. O classificador lê o dataset que adicionamos e cria uma árvore de decisão. No nosso caso seria uma árvore de decisão simples visto que, para deixar o exemplo simples, temos apenas uma variante que é o prefixo. Caso recebêssemos os valores do prefixo separadamente, a árvore seria bem mais complexa. Você pode visualizar essa árvore ao perguntar pelas regras</p>

<p><code>
@a.get_rules
</code></p>

<p>Com a árvore de decisão criada, ficou simples obter o rate para nosso prefixo.
```
prefix = ‘55118’
eval @a.get_rules</p>

<h1>‘0.025’</h1>

<p>```
Mas agora você diz: Peraê, você está dizendo que se apenas alimentar a variável prefixo com o número completo ele traz o resultado correto?
Ok, eu admito. Não é tão mágico assim. Para meu exemplo ficar completo, somente o que foi feito não resolveria, ja que, como eu disse, o valor que obteríamos seria uma string com o número inteiro. Caso eu coloque o valor inteiro da string na variável prefix não encontraria nenhum resultado pois o ID3 não faz predições. Faz apenas classificações.</p>

<p>```
@prefix = number
…</p>

<p>  def get_rate</p>

<pre><code>prefix = @prefix
result = (eval @a.get_rules)
</code></pre>

<p>  rescue</p>

<pre><code>if !@prefix.empty?
  @prefix.chop!
  get_rate
else
  raise ‘Sem rate para esse número’
end
</code></pre>

<p>  end
```</p>

<p>Ok. Ta certo. Você pode dizer que nesse exemplo eu usei o mesmo princípio de eliminar os números que não se encaixavam com nosso dataset, como o usado no Exterminador do Futuro 1, mas se a Skynet usou no T-800, quem sou eu para dizer algo contra?</p>

<p><a id="1"></a> <strong>1 - Não importa o que digam, a solução de matar todas as mulheres que se chamavam Sarah Connor para atingir a mãe do John Connor não parece muito inteligente.</strong></p>

<p><a id="2"></a> <strong>2 - Indicaria fazer esse exemplo com mais colunas, ou com outros casos para ver como se comporta a árvore de decisão em cada caso.</strong></p>
]]></content>
  </entry>
  
</feed>
